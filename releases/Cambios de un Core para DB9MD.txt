#OFICIAL
set_location_assignment PIN_AE15 -to USER_IO[7]
set_location_assignment PIN_AF17 -to USER_IO[6]
set_location_assignment PIN_AF15 -to USER_IO[5]
set_location_assignment PIN_AG16 -to USER_IO[4]
set_location_assignment PIN_AH11 -to USER_IO[3]
set_location_assignment PIN_AH12 -to USER_IO[2]
set_location_assignment PIN_AH9 -to USER_IO[1]
set_location_assignment PIN_AG11 -to USER_IO[0]

#FERNANDO
{6,3,5,7,1,2}
assign joy_o_db9 = {joy_p9_i, joy_p6_i,  joy_up_i, joy_down_i,joy_left_i, joy_right_i};   
set_location_assignment PIN_AF15 -to joy_up_i    USER_IO[5]
set_location_assignment PIN_AH9  -to joy_left_i  USER_IO[1]
set_location_assignment PIN_AH11 -to joy_p6_i    USER_IO[3]
set_location_assignment PIN_AF17 -to joy_p9_i    USER_IO[6]
set_location_assignment PIN_AH12 -to joy_right_i USER_IO[2]
set_location_assignment PIN_AE15 -to joy_down_i  USER_IO[7]
set_location_assignment PIN_AG11 -to db9_Select  USER_IO[0]
set_location_assignment PIN_AG16 -to splitter_select USER_IO[4]

Pasos para implementar DB9
1.- Clonar repo...
2.- Crear branch Joy_DB9MD
3.- Copiar fichero joydb9md.v a donde esten los fuentes
4.- Modificar el fichero files.qip y añadir la linea (cambiando ruta segun sea):
set_global_assignment -name VERILOG_FILE src/joydb9md.v

5.- Editar el fichero sys/sys.tcl y hacer los siguientes cambios:
>Añadir la linea USER_IO[7] en USER_PORT
#============================================================
# USER PORT
#============================================================
set_location_assignment PIN_AE15 -to USER_IO[7]
>Comentar la linea de SD_SPI_CS
#============================================================
# SPI SD
#============================================================
#set_location_assignment PIN_AE15 -to SD_SPI_CS

6.- Editar el fichero sys/sys_top.v
>Comentar la linea de SD_SPI_CS en los sitios que aparece
	////////// I/O ALT /////////
	//output        SD_SPI_CS,

`ifndef DUAL_SDRAM
	assign SDIO_DAT[2:1]= 2'bZZ;
	assign SDIO_DAT[3]  = SW[3] ? 1'bZ  : SD_CS;
	assign SDIO_CLK     = SW[3] ? 1'bZ  : SD_CLK;
	assign SDIO_CMD     = SW[3] ? 1'bZ  : SD_MOSI;
//	assign SD_SPI_CS    = mcp_sdcd ? ((~VGA_EN & sog & ~cs1) ? 1'b1 : 1'bZ) : SD_CS;
`else
//	assign SD_SPI_CS    = mcp_sdcd ? 1'bZ : SD_CS;
`endif
>Aumentar a 7 el USER_IO en la deficion y asignacion. Crear la variante user_mode y meterla en la definicion de emu.
	///////// USER IO ///////////
	inout   [7:0] USER_IO

////////////////  User I/O (USB 3.0 connector) /////////////////////////

assign USER_IO[0] = user_mode ? user_out[0] : !user_out[0]  ? 1'b0 : 1'bZ;
assign USER_IO[1] =                       !user_out[1]  ? 1'b0 : 1'bZ;
assign USER_IO[2] = !(SW[1] ? HDMI_I2S   : user_out[2]) ? 1'b0 : 1'bZ;
assign USER_IO[3] =                       !user_out[3]  ? 1'b0 : 1'bZ;
assign USER_IO[4] = user_mode ? user_out[4] : !(SW[1] ? HDMI_SCLK  : user_out[4]) ? 1'b0 : 1'bZ;
assign USER_IO[5] = !(SW[1] ? HDMI_LRCLK : user_out[5]) ? 1'b0 : 1'bZ;
assign USER_IO[6] =                       !user_out[6]  ? 1'b0 : 1'bZ;
assign USER_IO[7] =                       !user_out[7]  ? 1'b0 : 1'bZ;

assign user_in[0] = user_mode ? 1'b0 : USER_IO[0];
assign user_in[1] =         USER_IO[1];
assign user_in[2] = SW[1] | USER_IO[2];
assign user_in[3] =         USER_IO[3];
assign user_in[4] = user_mode ? 1'b0 : SW[1] | USER_IO[4];
assign user_in[5] = SW[1] | USER_IO[5];
assign user_in[6] =         USER_IO[6];
assign user_in[7] =         USER_IO[7];

..

wire  [7:0] user_out, user_in;
wire        user_mode;

..

	.USER_MODE(user_mode),
	.USER_OUT(user_out),
	.USER_IN(user_in)
);

endmodule
	
7. Editar el fichero "emu" que estara en el raiz con nombre del core .sv
>Crear la señal user_mode y aumentar el tamaño de user_*
    // Open-drain User port.
    // 0 - D+/RX
    // 1 - D-/TX
    // 2..6 - USR2..USR6
    // Set USER_OUT to 1 to read from USER_IN.
    output	      USER_MODE,
    input   [7:0] USER_IN,
    output  [7:0] USER_OUT
>Crear nuestras variables de control y quitar la asignacion "assign USER_OUT  = '1;	"
);
assign VGA_F1    = 0;

wire   joy_split, joy_mdsel;
wire   [5:0] joy_in = {USER_IN[6],USER_IN[3],USER_IN[5],USER_IN[7],USER_IN[1],USER_IN[2]};
assign USER_OUT  = |status[31:30] ? {3'b111,joy_split,3'b111,joy_mdsel} : '1;
assign USER_MODE = |status[31:30] ;

assign LED_USER  = ioctl_download;

>Crear la entrada del menu (Uso UV porque son 31:30 las dos ultimas de la O mayuscula)
 Si estuviera ocupadas habria que cambiarlas por otras

 "OUV,Serial SNAC DB9 Sega,Off,1 Player,2 Players;",	

>Ir al la definicion de los Joysticks y cambiar el nombre por *_USB en la def y en la llamada de HPS_IO
wire [21:0] gamma_bus;
wire [10:0] ps2_key;
wire [15:0] joy1_USB, joy2_USB;

hps_io #(.STRLEN(($size(CONF_STR)>>3) )) hps_io
(
	.clk_sys(clk_sys),
	.HPS_BUS(HPS_BUS),

	.conf_str(CONF_STR),
	
	.buttons(buttons),
	.status(status),
	.forced_scandoubler(forced_scandoubler),
	.gamma_bus(gamma_bus),


	.ioctl_download(ioctl_download),
	.ioctl_wr(ioctl_wr),
	.ioctl_addr(ioctl_addr),
	.ioctl_dout(ioctl_data),
	
	.joystick_0(joy1_USB),
	.joystick_1(joy2_USB),
	.ps2_key(ps2_key)
);

> Meter nuestro modulo justo antes de hps_io y Crear unos nuevos Wires con el nombre que tenia (sin el _USB) para hacer el intercambio con nuestro sistema
wire [15:0] joy1 = |status[31:30] ? {joydb9md_1[9],joydb9md_1[7],joydb9md_1[8],joydb9md_1[4:0]} : joy1_USB;
wire [15:0] joy2 =  status[31]    ? {joydb9md_2[9],joydb9md_2[8],joydb9md_2[7],joydb9md_2[4:0]} : status[30] ? joy1_USB : joy2_USB;

reg [15:0] joydb9md_1,joydb9md_2;
joy_db9md joy_db9md
(
  .clk       ( clk_sys    ), //35-50MHz
  .joy_split ( joy_split  ),
  .joy_mdsel ( joy_mdsel  ),
  .joy_in    ( joy_in     ),
  .joystick1 ( joydb9md_1 ),
  .joystick2 ( joydb9md_2 )	  
);


